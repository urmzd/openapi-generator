// Auto-generated by oag â€” do not edit

/** Error thrown when an SSE connection fails. */
export class SSEError extends Error {
  constructor(
    message: string,
    public readonly statusCode?: number,
    public readonly statusText?: string,
    public readonly body?: unknown,
    public readonly response?: Response,
  ) {
    super(message);
    this.name = "SSEError";
  }
}

/** Options for SSE streaming. */
export interface SSEOptions {
  signal?: AbortSignal;
  headers?: Record<string, string>;
  onOpen?: (response: Response) => void;
  onError?: (error: SSEError) => void;
}

/** Request interceptor type. */
type RequestInterceptor = (request: {
  url: string;
  init: RequestInit;
}) => { url: string; init: RequestInit } | Promise<{ url: string; init: RequestInit }>;

/**
 * Create an async generator that yields parsed SSE events from a fetch response.
 * Supports both GET and POST methods, handles `[DONE]` sentinel, and parses
 * `data:` lines as JSON.
 */
export async function* streamSse<T>(
  url: string,
  init: RequestInit & { headers?: Record<string, string> },
  options?: SSEOptions,
  requestInterceptor?: RequestInterceptor,
): AsyncGenerator<T, void, undefined> {
  let req = {
    url,
    init: {
      ...init,
      headers: {
        Accept: "text/event-stream",
        "Content-Type": "application/json",
        ...init.headers,
        ...options?.headers,
      },
      signal: options?.signal,
    } as RequestInit,
  };

  if (requestInterceptor) {
    req = await requestInterceptor(req);
  }

  const response = await fetch(req.url, req.init);

  if (!response.ok) {
    let body: unknown;
    try {
      const text = await response.text();
      body = text ? JSON.parse(text) : undefined;
    } catch {
      // body remains undefined if not valid JSON
    }
    const error = new SSEError(
      `SSE request failed: ${response.status} ${response.statusText}`,
      response.status,
      response.statusText,
      body,
      response,
    );
    options?.onError?.(error);
    throw error;
  }

  options?.onOpen?.(response);

  const reader = response.body?.getReader();
  if (!reader) {
    throw new SSEError("Response body is not readable");
  }

  const decoder = new TextDecoder();
  let buffer = "";

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() ?? "";

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith(":")) continue;

        if (trimmed.startsWith("data:")) {
          const data = trimmed.slice(5).trim();
          if (data === "[DONE]") return;
          try {
            yield JSON.parse(data) as T;
          } catch {
            // Skip non-JSON data lines
          }
        }
      }
    }

    // Process remaining buffer
    if (buffer.trim()) {
      const trimmed = buffer.trim();
      if (trimmed.startsWith("data:")) {
        const data = trimmed.slice(5).trim();
        if (data !== "[DONE]") {
          try {
            yield JSON.parse(data) as T;
          } catch {
            // Skip non-JSON data lines
          }
        }
      }
    }
  } finally {
    reader.releaseLock();
  }
}

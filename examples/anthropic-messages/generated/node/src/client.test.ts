// Auto-generated by oag â€” do not edit
import { describe, expect, it, vi } from "vitest";
import type { ClientConfig } from "./client";
import { ApiClient, ApiError } from "./client";
import type {
  CountTokensBody,
  CountTokensResponse2,
  CreateMessageBody,
  CreateMessageEventVariant1,
  CreateMessageEventVariant2,
  CreateMessageEventVariant3,
  CreateMessageEventVariant4,
  CreateMessageEventVariant5,
  CreateMessageEventVariant6,
  CreateMessageEventVariant7,
  CreateMessageEventVariant8,
  CreateMessageResponse,
  GetModelResponse,
  ListModelsResponse,
} from "./types";

function createMockFetch(status = 200, body: unknown = {}) {
  return vi.fn().mockResolvedValue({
    ok: status >= 200 && status < 300,
    status,
    statusText: status === 200 ? "OK" : "Error",
    headers: new Headers(),
    json: () => Promise.resolve(body),
    text: () => Promise.resolve(JSON.stringify(body)),
    body: null,
  } as unknown as Response);
}

function createClient(fetchFn?: typeof globalThis.fetch): ApiClient {
  const config: ClientConfig = {
    baseUrl: "https://api.test.com",
    fetch: fetchFn ?? createMockFetch(),
    retry: false,
  };
  return new ApiClient(config);
}

describe("ApiClient", () => {
  it("can be instantiated with config", () => {
    const client = createClient();
    expect(client).toBeInstanceOf(ApiClient);
  });

  it("can be instantiated with custom headers", () => {
    const config: ClientConfig = {
      baseUrl: "https://api.test.com",
      headers: { Authorization: "Bearer token" },
      fetch: createMockFetch(),
    };
    const client = new ApiClient(config);
    expect(client).toBeInstanceOf(ApiClient);
  });

  it("can be instantiated with custom fetch", () => {
    const mockFetch = createMockFetch();
    const client = createClient(mockFetch);
    expect(client).toBeInstanceOf(ApiClient);
  });

  describe("createMessageStream", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.createMessageStream).toBe("function");
    });

    it("returns an async iterable", () => {
      const client = createClient();
      const result = client.createMessageStream("test", {} as CreateMessageBody);
      expect(result).toBeDefined();
      expect(typeof result[Symbol.asyncIterator]).toBe("function");
    });
  });

  describe("createMessage", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.createMessage).toBe("function");
    });

    it("makes POST request to correct URL", async () => {
      const mockFetch = createMockFetch(200, {} as CreateMessageResponse);
      const client = createClient(mockFetch);
      await client.createMessage("test", {} as CreateMessageBody);
      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, init] = mockFetch.mock.calls[0];
      expect(url).toContain("/v1/messages");
      expect(init.method).toBe("POST");
    });

    it("sends request body", async () => {
      const mockFetch = createMockFetch(200, {} as CreateMessageResponse);
      const client = createClient(mockFetch);
      await client.createMessage("test", {} as CreateMessageBody);
      const [, init] = mockFetch.mock.calls[0];
      expect(init.body).toBeDefined();
    });

    it("throws ApiError on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      await expect(client.createMessage("test", {} as CreateMessageBody)).rejects.toThrow(ApiError);
    });
  });

  describe("createMessageRaw", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.createMessageRaw).toBe("function");
    });

    it("returns ApiResponse with ok, status, headers, data", async () => {
      const mockFetch = createMockFetch(200, {} as CreateMessageResponse);
      const client = createClient(mockFetch);
      const response = await client.createMessageRaw("test", {} as CreateMessageBody);
      expect(response.ok).toBe(true);
      expect(response.status).toBe(200);
      expect(response.headers).toBeInstanceOf(Headers);
      expect(response.data).toBeDefined();
    });

    it("does not throw on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      const response = await client.createMessageRaw("test", {} as CreateMessageBody);
      expect(response.ok).toBe(false);
      expect(response.status).toBe(500);
    });
  });

  describe("countTokens", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.countTokens).toBe("function");
    });

    it("makes POST request to correct URL", async () => {
      const mockFetch = createMockFetch(200, {} as CountTokensResponse2);
      const client = createClient(mockFetch);
      await client.countTokens("test", {} as CountTokensBody);
      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, init] = mockFetch.mock.calls[0];
      expect(url).toContain("/v1/messages/count_tokens");
      expect(init.method).toBe("POST");
    });

    it("sends request body", async () => {
      const mockFetch = createMockFetch(200, {} as CountTokensResponse2);
      const client = createClient(mockFetch);
      await client.countTokens("test", {} as CountTokensBody);
      const [, init] = mockFetch.mock.calls[0];
      expect(init.body).toBeDefined();
    });

    it("throws ApiError on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      await expect(client.countTokens("test", {} as CountTokensBody)).rejects.toThrow(ApiError);
    });
  });

  describe("countTokensRaw", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.countTokensRaw).toBe("function");
    });

    it("returns ApiResponse with ok, status, headers, data", async () => {
      const mockFetch = createMockFetch(200, {} as CountTokensResponse2);
      const client = createClient(mockFetch);
      const response = await client.countTokensRaw("test", {} as CountTokensBody);
      expect(response.ok).toBe(true);
      expect(response.status).toBe(200);
      expect(response.headers).toBeInstanceOf(Headers);
      expect(response.data).toBeDefined();
    });

    it("does not throw on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      const response = await client.countTokensRaw("test", {} as CountTokensBody);
      expect(response.ok).toBe(false);
      expect(response.status).toBe(500);
    });
  });

  describe("listModels", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.listModels).toBe("function");
    });

    it("makes GET request to correct URL", async () => {
      const mockFetch = createMockFetch(200, {} as ListModelsResponse);
      const client = createClient(mockFetch);
      await client.listModels("test");
      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, init] = mockFetch.mock.calls[0];
      expect(url).toContain("/v1/models");
      expect(init.method).toBe("GET");
    });

    it("throws ApiError on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      await expect(client.listModels("test")).rejects.toThrow(ApiError);
    });
  });

  describe("listModelsRaw", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.listModelsRaw).toBe("function");
    });

    it("returns ApiResponse with ok, status, headers, data", async () => {
      const mockFetch = createMockFetch(200, {} as ListModelsResponse);
      const client = createClient(mockFetch);
      const response = await client.listModelsRaw("test");
      expect(response.ok).toBe(true);
      expect(response.status).toBe(200);
      expect(response.headers).toBeInstanceOf(Headers);
      expect(response.data).toBeDefined();
    });

    it("does not throw on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      const response = await client.listModelsRaw("test");
      expect(response.ok).toBe(false);
      expect(response.status).toBe(500);
    });
  });

  describe("getModel", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.getModel).toBe("function");
    });

    it("makes GET request to correct URL", async () => {
      const mockFetch = createMockFetch(200, {} as GetModelResponse);
      const client = createClient(mockFetch);
      await client.getModel("test", "test");
      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, init] = mockFetch.mock.calls[0];
      expect(url).toContain("/v1/models/test");
      expect(init.method).toBe("GET");
    });

    it("throws ApiError on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      await expect(client.getModel("test", "test")).rejects.toThrow(ApiError);
    });
  });

  describe("getModelRaw", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.getModelRaw).toBe("function");
    });

    it("returns ApiResponse with ok, status, headers, data", async () => {
      const mockFetch = createMockFetch(200, {} as GetModelResponse);
      const client = createClient(mockFetch);
      const response = await client.getModelRaw("test", "test");
      expect(response.ok).toBe(true);
      expect(response.status).toBe(200);
      expect(response.headers).toBeInstanceOf(Headers);
      expect(response.data).toBeDefined();
    });

    it("does not throw on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      const response = await client.getModelRaw("test", "test");
      expect(response.ok).toBe(false);
      expect(response.status).toBe(500);
    });
  });

  describe("cancelBatch", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.cancelBatch).toBe("function");
    });

    it("makes DELETE request to correct URL", async () => {
      const mockFetch = createMockFetch(204);
      const client = createClient(mockFetch);
      await client.cancelBatch("test", "test");
      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, init] = mockFetch.mock.calls[0];
      expect(url).toContain("/v1/messages/batches/test");
      expect(init.method).toBe("DELETE");
    });

    it("returns undefined on 204", async () => {
      const mockFetch = createMockFetch(204);
      const client = createClient(mockFetch);
      const result = await client.cancelBatch("test", "test");
      expect(result).toBeUndefined();
    });
  });

  describe("cancelBatchRaw", () => {
    it("method exists", () => {
      const client = createClient();
      expect(typeof client.cancelBatchRaw).toBe("function");
    });

    it("returns ApiResponse with ok, status, headers", async () => {
      const mockFetch = createMockFetch(204);
      const client = createClient(mockFetch);
      const response = await client.cancelBatchRaw("test", "test");
      expect(response.ok).toBe(true);
      expect(response.status).toBe(204);
      expect(response.headers).toBeInstanceOf(Headers);
    });

    it("does not throw on non-OK response", async () => {
      const mockFetch = createMockFetch(500);
      const client = createClient(mockFetch);
      const response = await client.cancelBatchRaw("test", "test");
      expect(response.ok).toBe(false);
      expect(response.status).toBe(500);
    });
  });

  describe("retry", () => {
    it("retries on retryable status codes", async () => {
      const failResponse = {
        ok: false,
        status: 500,
        statusText: "Internal Server Error",
        headers: new Headers(),
        json: () => Promise.resolve({}),
        text: () => Promise.resolve("{}"),
        body: null,
      } as unknown as Response;
      const successResponse = {
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers(),
        json: () => Promise.resolve({ success: true }),
        text: () => Promise.resolve(JSON.stringify({ success: true })),
        body: null,
      } as unknown as Response;
      const mockFetch = vi
        .fn()
        .mockResolvedValueOnce(failResponse)
        .mockResolvedValueOnce(successResponse);

      const config: ClientConfig = {
        baseUrl: "https://api.test.com",
        fetch: mockFetch,
        retry: { maxRetries: 2, initialDelayMs: 1, maxDelayMs: 10 },
      };
      const client = new ApiClient(config);
      await client.createMessage("test", {} as CreateMessageBody);
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });
  });
});

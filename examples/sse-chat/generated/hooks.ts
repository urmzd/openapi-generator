// Auto-generated by oag — do not edit
import useSWR, { type SWRConfiguration } from "swr";
import useSWRMutation, { type SWRMutationConfiguration } from "swr/mutation";
import { useCallback, useRef, useState } from "react";
import { useApiClient } from "./provider";
import type {

  CreateChatCompletionStreamEvent,

  CreateChatCompletionStreamStreamEvent,

} from "./types";




/** List available models */

export function useListModels(, config?: SWRConfiguration<{ data: { id: string; name: string; provider: string; maxTokens?: number; capabilities?: string[] }[] }>) {
  const client = useApiClient();
  return useSWR<{ data: { id: string; name: string; provider: string; maxTokens?: number; capabilities?: string[] }[] }>(
    "/models",
    () => client.listModels(),
    config,
  );
}





/** Get a specific model */

export function useGetModel(modelId: string, config?: SWRConfiguration<{ id: string; name: string; provider: string; maxTokens?: number; capabilities?: string[] }>) {
  const client = useApiClient();
  return useSWR<{ id: string; name: string; provider: string; maxTokens?: number; capabilities?: string[] }>(
    ["/models/{modelId}" , modelId] as const,
    () => client.getModel(modelId),
    config,
  );
}





/** Create a chat completion */

export function useCreateChatCompletionStream() {
  const client = useApiClient();
  const [events, setEvents] = useState<CreateChatCompletionStreamEvent[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  const trigger = useCallback(async (body: { model: string; messages: { role: string; content: string }[]; temperature?: number; maxTokens?: number; stream?: boolean }) => {
    setEvents([]);
    setError(null);
    setIsStreaming(true);
    abortRef.current = new AbortController();

    try {
      for await (const event of client.createChatCompletionStream(body, { signal: abortRef.current.signal })) {
        setEvents((prev) => [...prev, event]);
      }
    } catch (err) {
      if (err instanceof DOMException && err.name === "AbortError") {
        // Intentional abort — not an error
      } else {
        setError(err instanceof Error ? err : new Error(String(err)));
      }
    } finally {
      setIsStreaming(false);
      abortRef.current = null;
    }
  }, [client]);

  const abort = useCallback(() => {
    abortRef.current?.abort();
  }, []);

  const reset = useCallback(() => {
    setEvents([]);
    setError(null);
  }, []);

  return { events, isStreaming, error, trigger, abort, reset };
}





/** Create a chat completion */

export function useCreateChatCompletion(config?: SWRMutationConfiguration<{ id: string; model: string; choices: { index: number; message: { role: string; content: string }; finishReason: string }[]; usage: { promptTokens: number; completionTokens: number; totalTokens: number } }, Error, string, { model: string; messages: { role: string; content: string }[]; temperature?: number; maxTokens?: number; stream?: boolean }>) {
  const client = useApiClient();
  return useSWRMutation<{ id: string; model: string; choices: { index: number; message: { role: string; content: string }; finishReason: string }[]; usage: { promptTokens: number; completionTokens: number; totalTokens: number } }, Error, string, { model: string; messages: { role: string; content: string }[]; temperature?: number; maxTokens?: number; stream?: boolean }>(
    "/chat/completions",
    (_key: string, { arg }: { arg: { model: string; messages: { role: string; content: string }[]; temperature?: number; maxTokens?: number; stream?: boolean } }) => client.createChatCompletion(arg),
    config,
  );
}





/** Stream a chat completion */

export function useCreateChatCompletionStream() {
  const client = useApiClient();
  const [events, setEvents] = useState<CreateChatCompletionStreamStreamEvent[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  const trigger = useCallback(async (body: { model: string; messages: { role: string; content: string }[]; temperature?: number; maxTokens?: number; stream?: boolean }) => {
    setEvents([]);
    setError(null);
    setIsStreaming(true);
    abortRef.current = new AbortController();

    try {
      for await (const event of client.createChatCompletionStream(body, { signal: abortRef.current.signal })) {
        setEvents((prev) => [...prev, event]);
      }
    } catch (err) {
      if (err instanceof DOMException && err.name === "AbortError") {
        // Intentional abort — not an error
      } else {
        setError(err instanceof Error ? err : new Error(String(err)));
      }
    } finally {
      setIsStreaming(false);
      abortRef.current = null;
    }
  }, [client]);

  const abort = useCallback(() => {
    abortRef.current?.abort();
  }, []);

  const reset = useCallback(() => {
    setEvents([]);
    setError(null);
  }, []);

  return { events, isStreaming, error, trigger, abort, reset };
}





/** Submit feedback for a completion */

export function useSubmitFeedback(config?: SWRMutationConfiguration<void, Error, string, { completionId: string; rating: number; comment?: string }>) {
  const client = useApiClient();
  return useSWRMutation<void, Error, string, { completionId: string; rating: number; comment?: string }>(
    "/chat/feedback",
    (_key: string, { arg }: { arg: { completionId: string; rating: number; comment?: string } }) => client.submitFeedback(arg),
    config,
  );
}


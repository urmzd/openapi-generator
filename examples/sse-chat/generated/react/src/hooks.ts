// Auto-generated by oag — do not edit

import { useCallback, useRef, useState } from "react";
import useSWR, { type SWRConfiguration } from "swr";
import useSWRMutation, { type SWRMutationConfiguration } from "swr/mutation";
import { useApiClient } from "./provider";
import type {
  CreateChatCompletionBody,
  CreateChatCompletionResponse,
  CreateChatCompletionStreamBody,
  CreateChatCompletionStreamEvent,
  CreateChatCompletionStreamStreamEvent,
  GetModelResponse,
  ListModelsResponse,
  SubmitFeedbackBody,
} from "./types";

/** List available models */

export function useListModels(config?: SWRConfiguration<ListModelsResponse>) {
  const client = useApiClient();
  return useSWR<ListModelsResponse>("/models", () => client.listModels(), config);
}

/** Get a specific model */

export function useGetModel(modelId: string, config?: SWRConfiguration<GetModelResponse>) {
  const client = useApiClient();
  return useSWR<GetModelResponse>(
    ["/models/{modelId}", modelId] as const,
    () => client.getModel(modelId),
    config,
  );
}

/** Create a chat completion */

export function useCreateChatCompletionStream() {
  const client = useApiClient();
  const [events, setEvents] = useState<CreateChatCompletionStreamEvent[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  const trigger = useCallback(
    async (body: CreateChatCompletionBody) => {
      setEvents([]);
      setError(null);
      setIsStreaming(true);
      abortRef.current = new AbortController();

      try {
        for await (const event of client.createChatCompletionStream(body, {
          signal: abortRef.current.signal,
        })) {
          setEvents((prev) => [...prev, event]);
        }
      } catch (err) {
        if (err instanceof DOMException && err.name === "AbortError") {
          // Intentional abort — not an error
        } else {
          setError(err instanceof Error ? err : new Error(String(err)));
        }
      } finally {
        setIsStreaming(false);
        abortRef.current = null;
      }
    },
    [client],
  );

  const abort = useCallback(() => {
    abortRef.current?.abort();
  }, []);

  const reset = useCallback(() => {
    setEvents([]);
    setError(null);
  }, []);

  return { events, isStreaming, error, trigger, abort, reset };
}

/** Create a chat completion */

export function useCreateChatCompletion(
  config?: SWRMutationConfiguration<
    CreateChatCompletionResponse,
    Error,
    string,
    CreateChatCompletionBody
  >,
) {
  const client = useApiClient();
  return useSWRMutation<CreateChatCompletionResponse, Error, string, CreateChatCompletionBody>(
    "/chat/completions",
    (_key: string, { arg }: { arg: CreateChatCompletionBody }) => client.createChatCompletion(arg),
    config,
  );
}

/** Stream a chat completion */

export function useCreateChatCompletionStream() {
  const client = useApiClient();
  const [events, setEvents] = useState<CreateChatCompletionStreamStreamEvent[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  const trigger = useCallback(
    async (body: CreateChatCompletionStreamBody) => {
      setEvents([]);
      setError(null);
      setIsStreaming(true);
      abortRef.current = new AbortController();

      try {
        for await (const event of client.createChatCompletionStream(body, {
          signal: abortRef.current.signal,
        })) {
          setEvents((prev) => [...prev, event]);
        }
      } catch (err) {
        if (err instanceof DOMException && err.name === "AbortError") {
          // Intentional abort — not an error
        } else {
          setError(err instanceof Error ? err : new Error(String(err)));
        }
      } finally {
        setIsStreaming(false);
        abortRef.current = null;
      }
    },
    [client],
  );

  const abort = useCallback(() => {
    abortRef.current?.abort();
  }, []);

  const reset = useCallback(() => {
    setEvents([]);
    setError(null);
  }, []);

  return { events, isStreaming, error, trigger, abort, reset };
}

/** Submit feedback for a completion */

export function useSubmitFeedback(
  config?: SWRMutationConfiguration<void, Error, string, SubmitFeedbackBody>,
) {
  const client = useApiClient();
  return useSWRMutation<void, Error, string, SubmitFeedbackBody>(
    "/chat/feedback",
    (_key: string, { arg }: { arg: SubmitFeedbackBody }) => client.submitFeedback(arg),
    config,
  );
}

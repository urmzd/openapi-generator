// Auto-generated by oag — do not edit
import type { RetryConfig } from "./client";

/** Error thrown when an SSE connection fails. */
export class SSEError extends Error {
  constructor(
    message: string,
    public readonly statusCode?: number,
    public readonly statusText?: string,
    public readonly body?: unknown,
    public readonly response?: Response,
  ) {
    super(message);
    this.name = "SSEError";
  }
}

/** Options for SSE streaming. */
export interface SSEOptions {
  signal?: AbortSignal;
  headers?: Record<string, string>;
  onOpen?: (response: Response) => void;
  onError?: (error: SSEError) => void;
  /** Retry configuration for the SSE connection attempt. */
  retry?: RetryConfig | false;
}

/** Request interceptor type. */
type RequestInterceptor = (request: {
  url: string;
  init: RequestInit;
}) => { url: string; init: RequestInit } | Promise<{ url: string; init: RequestInit }>;

const DEFAULT_SSE_RETRY_CONFIG: Required<RetryConfig> = {
  maxRetries: 3,
  initialDelayMs: 1000,
  maxDelayMs: 30000,
  backoffMultiplier: 2,
  retryableStatusCodes: [408, 429, 500, 502, 503, 504],
  retryOnNetworkError: true,
};

function calculateBackoff(attempt: number, config: Required<RetryConfig>): number {
  const delay = config.initialDelayMs * config.backoffMultiplier ** attempt;
  const capped = Math.min(delay, config.maxDelayMs);
  const jitter = capped * 0.25 * Math.random();
  return capped + jitter;
}

function parseRetryAfter(headers: Headers): number | undefined {
  const value = headers.get("retry-after");
  if (value === null) return undefined;
  const seconds = Number(value);
  if (!Number.isNaN(seconds)) return seconds * 1000;
  const date = Date.parse(value);
  if (!Number.isNaN(date)) return Math.max(0, date - Date.now());
  return undefined;
}

function sleep(ms: number, signal?: AbortSignal): Promise<void> {
  return new Promise((resolve, reject) => {
    if (signal?.aborted) {
      reject(signal.reason ?? new DOMException("Aborted", "AbortError"));
      return;
    }
    const timer = setTimeout(resolve, ms);
    signal?.addEventListener(
      "abort",
      () => {
        clearTimeout(timer);
        reject(signal.reason ?? new DOMException("Aborted", "AbortError"));
      },
      { once: true },
    );
  });
}

/**
 * Create an async generator that yields parsed SSE events from a fetch response.
 * Supports both GET and POST methods, handles `[DONE]` sentinel, and parses
 * `data:` lines as JSON. Retries the connection on retryable failures.
 */
export async function* streamSse<T>(
  url: string,
  init: RequestInit & { headers?: Record<string, string> },
  options?: SSEOptions,
  requestInterceptor?: RequestInterceptor,
  fetchFn: typeof globalThis.fetch = globalThis.fetch.bind(globalThis),
): AsyncGenerator<T, void, undefined> {
  let req = {
    url,
    init: {
      ...init,
      headers: {
        Accept: "text/event-stream",
        ...(init.body ? { "Content-Type": "application/json" } : {}),
        ...init.headers,
        ...options?.headers,
      },
      signal: options?.signal,
    } as RequestInit,
  };

  if (requestInterceptor) {
    req = await requestInterceptor(req);
  }

  const retryConfig =
    options?.retry === false ? false : { ...DEFAULT_SSE_RETRY_CONFIG, ...(options?.retry ?? {}) };

  const maxAttempts = retryConfig === false ? 1 : retryConfig.maxRetries + 1;

  let lastError: unknown;
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    let response: Response;
    try {
      response = await fetchFn(req.url, req.init);
    } catch (error) {
      lastError = error;
      if (
        retryConfig === false ||
        !retryConfig.retryOnNetworkError ||
        attempt === maxAttempts - 1
      ) {
        throw error;
      }
      if (error instanceof DOMException && error.name === "AbortError") {
        throw error;
      }
      const backoff = calculateBackoff(attempt, retryConfig);
      await sleep(backoff, options?.signal);
      continue;
    }

    if (!response.ok) {
      if (
        retryConfig !== false &&
        retryConfig.retryableStatusCodes.includes(response.status) &&
        attempt < maxAttempts - 1
      ) {
        const retryAfter = parseRetryAfter(response.headers);
        const backoff = retryAfter ?? calculateBackoff(attempt, retryConfig);
        await sleep(backoff, options?.signal);
        continue;
      }

      let body: unknown;
      const text = await response.text();
      if (text) {
        try {
          body = JSON.parse(text);
        } catch {
          body = text;
        }
      }
      const error = new SSEError(
        `SSE request failed: ${response.status} ${response.statusText}`,
        response.status,
        response.statusText,
        body,
        response,
      );
      options?.onError?.(error);
      throw error;
    }

    options?.onOpen?.(response);

    const reader = response.body?.getReader();
    if (!reader) {
      throw new SSEError("Response body is not readable");
    }

    const decoder = new TextDecoder();
    let buffer = "";

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() ?? "";

        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith(":")) continue;

          if (trimmed.startsWith("data:")) {
            const data = trimmed.slice(5).trim();
            if (data === "[DONE]") return;
            try {
              yield JSON.parse(data) as T;
            } catch {
              // Skip non-JSON data lines
            }
          }
        }
      }

      // Process remaining buffer
      if (buffer.trim()) {
        const trimmed = buffer.trim();
        if (trimmed.startsWith("data:")) {
          const data = trimmed.slice(5).trim();
          if (data !== "[DONE]") {
            try {
              yield JSON.parse(data) as T;
            } catch {
              // Skip non-JSON data lines
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }

    // If we got here, the stream completed successfully — no retry needed
    return;
  }

  throw lastError;
}

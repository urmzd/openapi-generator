// Auto-generated by oag — do not edit
import useSWR, { type SWRConfiguration } from "swr";
import useSWRMutation, { type SWRMutationConfiguration } from "swr/mutation";
import { useCallback, useRef, useState } from "react";
import { useApiClient } from "./provider";
import type {
{% for type_name in imported_types %}
  {{ type_name }},
{% endfor %}
} from "./types";
{% for hook in hooks %}

{% if hook.kind == "query" %}
{% if hook.description %}
/** {{ hook.description }} */
{% endif %}
export function {{ hook.hook_name }}({{ hook.params_signature }}, config?: SWRConfiguration<{{ hook.return_type }}>) {
  const client = useApiClient();
  return useSWR<{{ hook.return_type }}>(
    {{ hook.swr_key }},
    () => client.{{ hook.method_name }}({{ hook.call_args }}),
    config,
  );
}
{% elif hook.kind == "mutation" %}
{% if hook.description %}
/** {{ hook.description }} */
{% endif %}
export function {{ hook.hook_name }}({{ hook.path_params_signature }}config?: SWRMutationConfiguration<{{ hook.return_type }}, Error, string, {{ hook.body_type }}>) {
  const client = useApiClient();
  return useSWRMutation<{{ hook.return_type }}, Error, string, {{ hook.body_type }}>(
    {{ hook.swr_key }},
    (_key: string, { arg }: { arg: {{ hook.body_type }} }) => client.{{ hook.method_name }}({{ hook.call_args }}),
    config,
  );
}
{% elif hook.kind == "sse" %}
{% if hook.description %}
/** {{ hook.description }} */
{% endif %}
export function {{ hook.hook_name }}({{ hook.path_params_signature }}) {
  const client = useApiClient();
  const [events, setEvents] = useState<{{ hook.event_type }}[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  const trigger = useCallback(async ({{ hook.trigger_params }}) => {
    setEvents([]);
    setError(null);
    setIsStreaming(true);
    abortRef.current = new AbortController();

    try {
      for await (const event of client.{{ hook.method_name }}({{ hook.stream_call_args }}, { signal: abortRef.current.signal })) {
        setEvents((prev) => [...prev, event]);
      }
    } catch (err) {
      if (err instanceof DOMException && err.name === "AbortError") {
        // Intentional abort — not an error
      } else {
        setError(err instanceof Error ? err : new Error(String(err)));
      }
    } finally {
      setIsStreaming(false);
      abortRef.current = null;
    }
  }, [client{{ hook.deps }}]);

  const abort = useCallback(() => {
    abortRef.current?.abort();
  }, []);

  const reset = useCallback(() => {
    setEvents([]);
    setError(null);
  }, []);

  return { events, isStreaming, error, trigger, abort, reset };
}
{% endif %}
{% endfor %}

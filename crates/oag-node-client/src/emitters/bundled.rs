use oag_core::ir::IrSpec;

use crate::emitters;

/// Emit a single `index.ts` file that bundles types + sse + client together.
/// Strips relative imports between modules since everything is inlined.
pub fn emit_bundled(ir: &IrSpec, no_jsdoc: bool) -> String {
    let types_content = emitters::types::emit_types(ir);
    let sse_content = emitters::sse::emit_sse();
    let client_content = emitters::client::emit_client(ir, no_jsdoc);

    let mut output = String::new();
    output.push_str("// Auto-generated by oag — do not edit (bundled)\n\n");

    // Append types (already standalone, no imports to strip)
    output.push_str("// === Types ===\n\n");
    output.push_str(&strip_auto_generated_header(&types_content));
    output.push('\n');

    // Append SSE runtime (strip header)
    output.push_str("// === SSE Runtime ===\n\n");
    output.push_str(&strip_auto_generated_header(&sse_content));
    output.push('\n');

    // Append client (strip imports from ./types and ./sse since they're inlined)
    output.push_str("// === Client ===\n\n");
    let client_stripped = strip_relative_imports(&strip_auto_generated_header(&client_content));
    output.push_str(&client_stripped);

    output
}

/// Remove the "// Auto-generated by oag — do not edit" header line.
fn strip_auto_generated_header(content: &str) -> String {
    content
        .lines()
        .filter(|line| !line.starts_with("// Auto-generated by oag"))
        .collect::<Vec<_>>()
        .join("\n")
}

/// Remove import lines that reference relative modules (./types, ./sse, ./client).
fn strip_relative_imports(content: &str) -> String {
    let lines: Vec<&str> = content.lines().collect();
    let mut result = Vec::new();
    let mut i = 0;

    let is_relative = |s: &str| {
        s.contains("\"./types\"") || s.contains("\"./sse\"") || s.contains("\"./client\"")
    };

    while i < lines.len() {
        let trimmed = lines[i].trim();

        if trimmed.starts_with("import ") || trimmed.starts_with("import type ") {
            // Single-line import ending with `;`
            if trimmed.ends_with(';') {
                if is_relative(trimmed) {
                    i += 1;
                    continue;
                }
                result.push(lines[i]);
                i += 1;
                continue;
            }

            // Multi-line import — scan ahead to the closing `} from "...";`
            let start = i;
            i += 1;
            let mut found_close = false;
            while i < lines.len() {
                let t = lines[i].trim();
                if t.starts_with("} from ") {
                    found_close = true;
                    if is_relative(t) {
                        // Skip entire block (start..=i)
                        i += 1;
                    } else {
                        // Keep entire block
                        result.extend_from_slice(&lines[start..=i]);
                        i += 1;
                    }
                    break;
                }
                i += 1;
            }
            if !found_close {
                // Unterminated import block — keep lines as-is
                result.extend_from_slice(&lines[start..i]);
            }
            continue;
        }

        result.push(lines[i]);
        i += 1;
    }

    result.join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_strip_relative_imports() {
        let content = r#"import type {
  Pet,
  NewPet,
} from "./types";
import { streamSse, type SSEOptions } from "./sse";

export class ApiClient {"#;

        let stripped = strip_relative_imports(content);
        assert!(!stripped.contains("from \"./types\""));
        assert!(!stripped.contains("from \"./sse\""));
        assert!(stripped.contains("export class ApiClient {"));
    }

    #[test]
    fn test_strip_auto_generated_header() {
        let content = "// Auto-generated by oag — do not edit\nexport interface Foo {}";
        let stripped = strip_auto_generated_header(content);
        assert!(!stripped.contains("Auto-generated"));
        assert!(stripped.contains("export interface Foo {}"));
    }
}

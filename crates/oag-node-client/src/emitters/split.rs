use oag_core::GeneratedFile;
use oag_core::config::SplitBy;
use oag_core::ir::{IrSpec, OperationGroup, group_operations};

use crate::emitters;

/// Emit files for split layout mode.
///
/// Produces:
/// - `types.ts` — centralized types (same as modular)
/// - `_client-base.ts` — the ApiClient class with the private `request` method
/// - `{group}.ts` — per-group files with standalone functions
/// - `sse.ts` — SSE runtime (same as modular)
/// - `index.ts` — barrel re-export
pub fn emit_split(ir: &IrSpec, no_jsdoc: bool, split_by: SplitBy) -> Vec<GeneratedFile> {
    let groups = group_operations(ir, split_by);
    let mut files = Vec::new();

    // Centralized types
    files.push(GeneratedFile {
        path: "types.ts".to_string(),
        content: emitters::types::emit_types(ir),
    });

    // SSE runtime
    files.push(GeneratedFile {
        path: "sse.ts".to_string(),
        content: emitters::sse::emit_sse(),
    });

    // Client base — full client class
    files.push(GeneratedFile {
        path: "client.ts".to_string(),
        content: emitters::client::emit_client(ir, no_jsdoc),
    });

    // Per-group files — re-export from client for the group's operations
    let mut group_names = Vec::new();
    for group in &groups {
        let group_file_name = format!("{}.ts", group.name.snake_case);
        let content = emit_group_file(ir, group);
        group_names.push(group.name.snake_case.clone());
        files.push(GeneratedFile {
            path: group_file_name,
            content,
        });
    }

    // Index barrel
    files.push(GeneratedFile {
        path: "index.ts".to_string(),
        content: emit_split_index(&group_names),
    });

    files
}

/// Emit a per-group file that re-exports the relevant operations from the client.
fn emit_group_file(ir: &IrSpec, group: &OperationGroup) -> String {
    let mut lines = Vec::new();
    lines.push("// Auto-generated by oag — do not edit".to_string());
    lines.push(format!("// Operations group: {}", group.name.original));
    lines.push(String::new());

    // Collect the operation names for this group
    let op_names: Vec<&str> = group
        .operation_indices
        .iter()
        .map(|&i| ir.operations[i].name.camel_case.as_str())
        .collect();

    lines.push("// This group contains the following operations:".to_string());
    for name in &op_names {
        lines.push(format!("//   - {name}"));
    }
    lines.push(String::new());
    lines.push("// Import the client and call the relevant methods:".to_string());
    lines.push("// import { ApiClient } from \"./client\";".to_string());
    lines.push(String::new());
    lines.push("export { ApiClient } from \"./client\";".to_string());
    lines.push("export * from \"./types\";".to_string());

    lines.join("\n") + "\n"
}

/// Emit the barrel index for split mode.
fn emit_split_index(group_names: &[String]) -> String {
    let mut lines = vec![
        "// Auto-generated by oag — do not edit".to_string(),
        "export * from \"./types\";".to_string(),
        "export { ApiClient, type ClientConfig, type RequestOptions } from \"./client\";"
            .to_string(),
        "export { streamSse, SSEError, type SSEOptions } from \"./sse\";".to_string(),
    ];

    for name in group_names {
        lines.push(format!("export * from \"./{name}\";"));
    }

    lines.join("\n") + "\n"
}

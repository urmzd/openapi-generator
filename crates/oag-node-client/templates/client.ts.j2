// Auto-generated by oag â€” do not edit
import type {
{% for type_name in imported_types %}
  {{ type_name }},
{% endfor %}
} from "./types";
{% if has_sse %}
import { type SSEOptions, streamSse } from "./sse";
{% endif %}

/** Options for API requests. */
export interface RequestOptions {
  signal?: AbortSignal;
  headers?: Record<string, string>;
}

/** Configuration for the API client. */
export interface ClientConfig {
  baseUrl: string;
  headers?: Record<string, string>;
  fetch?: typeof globalThis.fetch;
  requestInterceptor?: (request: { url: string; init: RequestInit }) =>
    { url: string; init: RequestInit } | Promise<{ url: string; init: RequestInit }>;
}

/** Error thrown when an API request returns a non-OK status. */
export class ApiError extends Error {
  constructor(
    message: string,
    public readonly statusCode: number,
    public readonly statusText: string,
    public readonly body?: unknown,
  ) {
    super(message);
    this.name = "ApiError";
  }
}

/** API client for {{ title }}. */
export class ApiClient {
  private readonly baseUrl: string;
  private readonly headers: Record<string, string>;
  private readonly fetchFn: typeof globalThis.fetch;
  private readonly requestInterceptor?: ClientConfig["requestInterceptor"];

  constructor(config: ClientConfig) {
    this.baseUrl = config.baseUrl.replace(/\/$/, "");
    this.headers = config.headers ?? {};
    this.fetchFn = config.fetch ?? globalThis.fetch.bind(globalThis);
    this.requestInterceptor = config.requestInterceptor;
  }

  private async request<T>(
    method: string,
    path: string,
    options?: RequestOptions & {
      body?: unknown;
      query?: Record<string, unknown>;
      contentType?: string;
    },
  ): Promise<T> {
    let url = `${this.baseUrl}${path}`;
    if (options?.query) {
      const params = new URLSearchParams();
      for (const [key, value] of Object.entries(options.query)) {
        if (value !== undefined && value !== null) {
          if (Array.isArray(value)) {
            for (const v of value) {
              params.append(key, String(v));
            }
          } else {
            params.set(key, String(value));
          }
        }
      }
      const qs = params.toString();
      if (qs) url += `?${qs}`;
    }

    const hasBody = options?.body !== undefined;
    const contentType = options?.contentType ?? "application/json";
    let req = {
      url,
      init: {
        method,
        headers: {
          ...(hasBody ? { "Content-Type": contentType } : {}),
          ...this.headers,
          ...options?.headers,
        } as Record<string, string>,
        body: hasBody
          ? contentType === "application/json"
            ? JSON.stringify(options.body)
            : options.body as BodyInit
          : undefined,
        signal: options?.signal,
      } as RequestInit,
    };

    if (this.requestInterceptor) {
      req = await this.requestInterceptor(req);
    }

    const response = await this.fetchFn(req.url, req.init);

    if (!response.ok) {
      let body: unknown;
      const text = await response.text();
      if (text) {
        try {
          body = JSON.parse(text);
        } catch {
          body = text;
        }
      }
      throw new ApiError(
        `API request failed: ${response.status} ${response.statusText}`,
        response.status,
        response.statusText,
        body,
      );
    }

    if (response.status === 204) {
      return undefined as T;
    }

    const text = await response.text();
    return text ? JSON.parse(text) as T : undefined as T;
  }
{% for op in operations %}

{% if op.description %}
  /** {{ op.description | escape_jsdoc }} */
{% elif op.summary %}
  /** {{ op.summary | escape_jsdoc }} */
{% endif %}
{% if op.deprecated %}
  /** @deprecated */
{% endif %}
{% if op.kind == "standard" %}
  async {{ op.method_name }}({{ op.params_signature }}): Promise<{{ op.return_type }}> {
{% if op.has_path_params %}
    let path = "{{ op.path }}";
{% for param in op.path_params %}
    path = path.replace("{{ "{" }}{{ param.original_name }}{{ "}" }}", encodeURIComponent(String({{ param.name }})));
{% endfor %}
{% else %}
    const path = "{{ op.path }}";
{% endif %}
{% if op.has_header_params %}
    const _hdr: Record<string, string> = {};
    for (const [k, v] of Object.entries({ {{ op.header_params_obj }} })) {
      if (v !== undefined && v !== null) _hdr[k] = String(v);
    }
{% endif %}
    return this.request<{{ op.return_type }}>("{{ op.http_method }}", path, {
{% if op.has_body %}
      body,
      contentType: "{{ op.body_content_type }}",
{% endif %}
{% if op.has_query_params %}
      query: { {{ op.query_params_obj }} },
{% endif %}
{% if op.has_header_params %}
      signal: options?.signal,
      headers: { ..._hdr, ...options?.headers },
{% else %}
      ...options,
{% endif %}
    });
  }
{% elif op.kind == "sse" %}
  async *{{ op.method_name }}({{ op.params_signature }}): AsyncGenerator<{{ op.return_type }}> {
{% if op.has_path_params %}
    let path = "{{ op.path }}";
{% for param in op.path_params %}
    path = path.replace("{{ "{" }}{{ param.original_name }}{{ "}" }}", encodeURIComponent(String({{ param.name }})));
{% endfor %}
{% else %}
    const path = "{{ op.path }}";
{% endif %}
    let url = `${this.baseUrl}${path}`;
{% if op.has_query_params %}
    const _q = new URLSearchParams();
    for (const [k, v] of Object.entries({ {{ op.query_params_obj }} })) {
      if (v !== undefined && v !== null) {
        if (Array.isArray(v)) {
          for (const item of v) {
            _q.append(k, String(item));
          }
        } else {
          _q.set(k, String(v));
        }
      }
    }
    const _qs = _q.toString();
    if (_qs) url += `?${_qs}`;
{% endif %}
{% if op.has_header_params %}
    const _hdr: Record<string, string> = {};
    for (const [k, v] of Object.entries({ {{ op.header_params_obj }} })) {
      if (v !== undefined && v !== null) _hdr[k] = String(v);
    }
{% endif %}
    yield* streamSse<{{ op.return_type }}>(url, {
      method: "{{ op.http_method }}",
{% if op.has_body %}
{% if op.body_content_type == "application/json" %}
      body: JSON.stringify(body),
{% else %}
      body: body as BodyInit,
{% endif %}
{% endif %}
{% if op.has_header_params %}
      headers: { ...this.headers, ..._hdr, ...options?.headers },
{% else %}
      headers: { ...this.headers, ...options?.headers },
{% endif %}
    }, options, this.requestInterceptor, this.fetchFn);
  }
{% elif op.kind == "void" %}
  async {{ op.method_name }}({{ op.params_signature }}): Promise<void> {
{% if op.has_path_params %}
    let path = "{{ op.path }}";
{% for param in op.path_params %}
    path = path.replace("{{ "{" }}{{ param.original_name }}{{ "}" }}", encodeURIComponent(String({{ param.name }})));
{% endfor %}
{% else %}
    const path = "{{ op.path }}";
{% endif %}
{% if op.has_header_params %}
    const _hdr: Record<string, string> = {};
    for (const [k, v] of Object.entries({ {{ op.header_params_obj }} })) {
      if (v !== undefined && v !== null) _hdr[k] = String(v);
    }
{% endif %}
    await this.request<void>("{{ op.http_method }}", path, {
{% if op.has_body %}
      body,
      contentType: "{{ op.body_content_type }}",
{% endif %}
{% if op.has_query_params %}
      query: { {{ op.query_params_obj }} },
{% endif %}
{% if op.has_header_params %}
      signal: options?.signal,
      headers: { ..._hdr, ...options?.headers },
{% else %}
      ...options,
{% endif %}
    });
  }
{% endif %}
{% endfor %}
}
